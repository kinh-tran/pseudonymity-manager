import require$$1, { existsSync, lstatSync, readdirSync, readFileSync, writeFileSync } from 'fs';
import require$$0, { spawn } from 'child_process';
import require$$2, { resolve } from 'path';

var commandExists$1 = {exports: {}};

var exec = require$$0.exec;
var execSync = require$$0.execSync;
var fs = require$$1;
var path = require$$2;
var access = fs.access;
var accessSync = fs.accessSync;
var constants = fs.constants || fs;

var isUsingWindows = process.platform == 'win32';

var fileNotExists = function(commandName, callback){
    access(commandName, constants.F_OK,
    function(err){
        callback(!err);
    });
};

var fileNotExistsSync = function(commandName){
    try{
        accessSync(commandName, constants.F_OK);
        return false;
    }catch(e){
        return true;
    }
};

var localExecutable = function(commandName, callback){
    access(commandName, constants.F_OK | constants.X_OK,
        function(err){
        callback(null, !err);
    });
};

var localExecutableSync = function(commandName){
    try{
        accessSync(commandName, constants.F_OK | constants.X_OK);
        return true;
    }catch(e){
        return false;
    }
};

var commandExistsUnix = function(commandName, cleanedCommandName, callback) {

    fileNotExists(commandName, function(isFile){

        if(!isFile){
            exec('command -v ' + cleanedCommandName +
                  ' 2>/dev/null' +
                  ' && { echo >&1 ' + cleanedCommandName + '; exit 0; }',
                  function (error, stdout, stderr) {
                      callback(null, !!stdout);
                  });
            return;
        }

        localExecutable(commandName, callback);
    });

};

var commandExistsWindows = function(commandName, cleanedCommandName, callback) {
  // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
  if (!(/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName))) {
    callback(null, false);
    return;
  }
  exec('where ' + cleanedCommandName,
    function (error) {
      if (error !== null){
        callback(null, false);
      } else {
        callback(null, true);
      }
    }
  );
};

var commandExistsUnixSync = function(commandName, cleanedCommandName) {
  if(fileNotExistsSync(commandName)){
      try {
        var stdout = execSync('command -v ' + cleanedCommandName +
              ' 2>/dev/null' +
              ' && { echo >&1 ' + cleanedCommandName + '; exit 0; }'
              );
        return !!stdout;
      } catch (error) {
        return false;
      }
  }
  return localExecutableSync(commandName);
};

var commandExistsWindowsSync = function(commandName, cleanedCommandName, callback) {
  // Regex from Julio from: https://stackoverflow.com/questions/51494579/regex-windows-path-validator
  if (!(/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName))) {
    return false;
  }
  try {
      var stdout = execSync('where ' + cleanedCommandName, {stdio: []});
      return !!stdout;
  } catch (error) {
      return false;
  }
};

var cleanInput = function(s) {
  if (/[^A-Za-z0-9_\/:=-]/.test(s)) {
    s = "'"+s.replace(/'/g,"'\\''")+"'";
    s = s.replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
      .replace(/\\'''/g, "\\'" ); // remove non-escaped single-quote if there are enclosed between 2 escaped
  }
  return s;
};

if (isUsingWindows) {
  cleanInput = function(s) {
    var isPathName = /[\\]/.test(s);
    if (isPathName) {
      var dirname = '"' + path.dirname(s) + '"';
      var basename = '"' + path.basename(s) + '"';
      return dirname + ':' + basename;
    }
    return '"' + s + '"';
  };
}

commandExists$1.exports = function commandExists(commandName, callback) {
  var cleanedCommandName = cleanInput(commandName);
  if (!callback && typeof Promise !== 'undefined') {
    return new Promise(function(resolve, reject){
      commandExists(commandName, function(error, output) {
        if (output) {
          resolve(commandName);
        } else {
          reject(error);
        }
      });
    });
  }
  if (isUsingWindows) {
    commandExistsWindows(commandName, cleanedCommandName, callback);
  } else {
    commandExistsUnix(commandName, cleanedCommandName, callback);
  }
};

commandExists$1.exports.sync = function(commandName) {
  var cleanedCommandName = cleanInput(commandName);
  if (isUsingWindows) {
    return commandExistsWindowsSync(commandName, cleanedCommandName);
  } else {
    return commandExistsUnixSync(commandName, cleanedCommandName);
  }
};

var commandExistsExports = commandExists$1.exports;

var commandExists = commandExistsExports;

function getOpenVpnBin() {
    switch (process.platform) {
        case "win32":
            if (existsSync("C:\\Program Files\\OpenVPN\\bin\\openvpn.exe")) {
                return "C:\\Program Files\\OpenVPN\\bin\\openvpn.exe";
            }
            else if (existsSync("C:\\Program Files (x86)\\OpenVPN\\bin\\openvpn.exe")) {
                return "C:\\Program Files (x86)\\OpenVPN\\bin\\openvpn.exe";
            }
            else {
                throw new Error("OpenVPN binary not found.");
            }
        default:
            if (commandExists.sync("openvpn"))
                return "openvpn";
            else
                throw new Error("OpenVPN binary not found.");
    }
}

class OpenVpnController {
    constructor(openVpnBin, enableLogging = false) {
        this.openVpnProcess = null;
        this.openVpnLog = [];
        this.status = "disconnected";
        this.openVpnBin = openVpnBin !== null && openVpnBin !== void 0 ? openVpnBin : getOpenVpnBin();
        this.enabledLogging = enableLogging;
    }
    /**
     * Connects to the VPN using the specified config file.
     *
     * @param configPath Full path to the .ovpn config file.
     */
    connect(configPath, auth) {
        if (!existsSync(configPath))
            throw new Error("Config file not found.");
        if (lstatSync(configPath).isDirectory())
            throw new Error("Config file cannot be a directory.");
        if (!configPath.endsWith(".ovpn"))
            throw new Error("Config file must be an .ovpn file.");
        if (this.openVpnProcess)
            throw new Error("Already connected.");
        this.config = configPath;
        this.openVpnProcess = spawn(this.openVpnBin, ["--config", configPath]);
        this.status = "connecting";
        return new Promise((resolve, reject) => {
            let skipPostAuthError = false;
            this.openVpnProcess.stderr.on("data", (err) => {
                const s = new String(err.toString());
                // handle auth
                // for some reason, the auth prompt is sent to stderr
                if (s.includes("Enter Auth Username:")) {
                    if (!auth)
                        throw new Error("Auth required but not provided.");
                    if (this.enabledLogging)
                        console.log("Enter Auth Username: " + auth.user);
                    this.openVpnProcess.stdin.write(`${auth.user}\n`);
                    return;
                }
                else if (s.includes("Enter Auth Password:")) {
                    if (!auth)
                        throw new Error("Auth required but not provided.");
                    if (this.enabledLogging)
                        console.log("Enter Auth Password: " +
                            auth.pass.replace(/./g, "*"));
                    this.openVpnProcess.stdin.write(`${auth.pass}\n`);
                    skipPostAuthError = true;
                    return;
                }
                else if (skipPostAuthError) {
                    // skip the error that occurs after auth
                    // this error consists of purely whitespace
                    // so only skip if the string is empty after trimming
                    skipPostAuthError = false;
                    if (s.trim() === "")
                        return;
                }
                console.error("Error: ", s);
                this.disconnect();
                reject(s);
            });
            this.openVpnProcess.on("exit", (code, signal) => {
                const errorMsg = `OpenVPN process exited with code ${code} and signal ${signal} before connection could be established.`;
                console.error(errorMsg);
                this.disconnect();
                reject(new Error(errorMsg));
            });
            this.openVpnProcess.stdout.on("data", (msg) => {
                const msgStr = msg.toString();
                this.openVpnLog.push(msgStr);
                if (this.enabledLogging)
                    console.log(msgStr);
                if (msgStr
                    .toLowerCase()
                    .includes("initialization sequence completed")) {
                    this.status = "connected";
                    resolve();
                }
            });
        });
    }
    /**
     * Disconnects from the VPN.
     */
    disconnect() {
        if (this.openVpnProcess) {
            const killed = this.openVpnProcess.kill();
            if (!killed)
                throw new Error("Failed to kill OpenVPN process.");
            this.openVpnProcess = null;
            this.config = "";
            this.status = "disconnected";
        }
        else {
            throw new Error("Not connected.");
        }
    }
    /**
     * Gets the log of the OpenVPN process.
     *
     * @returns A copy of the log.
     */
    getLog() {
        return [...this.openVpnLog];
    }
    /**
     * Clears the currently stored log.
     */
    clearLog() {
        this.openVpnLog = [];
    }
    /**
     * Gets the path to the config being used.
     *
     * @returns The path to the config being used.
     */
    getConfig() {
        return this.config;
    }
    /**
     * Gets the controller's current status.
     *
     * @returns The controller's current status.
     */
    getStatus() {
        return this.status;
    }
}

const countryCodes = [
    "AE",
    "AR",
    "AT",
    "AU",
    "BE",
    "BG",
    "BR",
    "CA",
    "CH",
    "CL",
    "CO",
    "CR",
    "CY",
    "CZ",
    "DE",
    "DK",
    "EC",
    "EE",
    "EG",
    "ES",
    "FI",
    "FR",
    "GE",
    "GR",
    "HK",
    "HR",
    "HU",
    "IE",
    "IL",
    "IN",
    "IS",
    "IT",
    "JP",
    "KH",
    "KR",
    "LT",
    "LU",
    "LV",
    "MD",
    "MK",
    "MM",
    "MT",
    "MX",
    "MY",
    "NG",
    "NL",
    "NO",
    "NZ",
    "PE",
    "PH",
    "PL",
    "PR",
    "PT",
    "RO",
    "RS",
    "RU",
    "SE",
    "SG",
    "SI",
    "SK",
    "TH",
    "TR",
    "TW",
    "UA",
    "UK",
    "US",
    "VN",
    "ZA",
];

class ProtonVpnController {
    constructor(configDir, auth, openVpnOptions) {
        this.configs = new Map();
        this.configDir = this.validateConfigDir(configDir);
        this.configs = this.getCountryConfigs(configDir);
        this.auth = auth;
        this.openVpnController = new OpenVpnController(openVpnOptions === null || openVpnOptions === void 0 ? void 0 : openVpnOptions.openVpnBin, openVpnOptions === null || openVpnOptions === void 0 ? void 0 : openVpnOptions.enableLogging);
    }
    connect(country) {
        if (country === "random") {
            country =
                countryCodes[Math.floor(Math.random() * countryCodes.length)];
        }
        if (!this.configs.has(country))
            throw new Error("Config not found.");
        return this.openVpnController.connect(this.configs.get(country), this.auth);
    }
    disconnect() {
        return this.openVpnController.disconnect();
    }
    getStatus() {
        return this.openVpnController.getStatus();
    }
    validateConfigDir(dir) {
        if (!existsSync(dir))
            throw new Error("Config directory not found.");
        if (!lstatSync(dir).isDirectory())
            throw new Error("Config directory must be a directory.");
        const files = readdirSync(dir);
        if (files.length === 0)
            throw new Error("Config directory is empty.");
        for (const file of files) {
            if (!file.endsWith(".ovpn"))
                throw new Error("Config directory contains non .ovpn files.");
        }
        return dir;
    }
    getCountryConfigs(dir) {
        const configs = new Map();
        const files = readdirSync(dir);
        countryCodes.forEach((countryCode) => {
            const config = files.find((f) => f.startsWith(countryCode.toLowerCase()));
            if (!config)
                throw new Error(`Config for ${countryCode} not found.`);
            configs.set(countryCode, resolve(dir, config));
        });
        return configs;
    }
}

function fixConfigCompressionError(configPath) {
    if (!existsSync(configPath))
        throw new Error("Config file not found.");
    if (lstatSync(configPath).isDirectory())
        throw new Error("Config file cannot be a directory.");
    if (!configPath.endsWith(".ovpn"))
        throw new Error("Config file must be an .ovpn file.");
    let f = readFileSync(configPath, "utf-8");
    f = f.replace("fast-io", `fast-io\n\n${!f.includes("comp-lzo") ? "comp-lzo yes" : ""}\n${!f.includes("allow-compression") ? "allow-compression yes" : ""}`);
    if (!f.includes("block-outside-dns"))
        f = f.replace("fast-io", "fast-io\nblock-outside-dns");
    writeFileSync(configPath, f);
}
function fixConfigCompressionErrorDir(dir) {
    if (!existsSync(dir))
        throw new Error("Config directory not found.");
    if (!lstatSync(dir).isDirectory())
        throw new Error("Config directory must be a directory.");
    const files = readdirSync(dir);
    for (const file of files) {
        fixConfigCompressionError(resolve(dir, file));
    }
}

export { OpenVpnController, ProtonVpnController, fixConfigCompressionError, fixConfigCompressionErrorDir };
//# sourceMappingURL=index.esm.js.map
